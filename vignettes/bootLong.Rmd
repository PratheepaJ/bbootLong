---
title: "Workflow : The Block Bootstrap Method for Longitudinal Microbiome Data"
author:
  name: Pratheepa Jeganathan
  affiliation: Department of Statistics, Stanford University
  email: jpratheepa31@gmail.com
date: "`r Sys.Date()`"
output: 
    rmarkdown::html_vignette:
        toc_float:  true
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: bootLong.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Install [R](https://www.r-project.org/) and [RStudio](https://www.rstudio.com/). Open this `Rmd` file in RStudio. Then run the following code to install all required packages.


Install packages: 
```{r install_packages}
pkgs <- c("ggplot2","dplyr","tidyr",
          "phyloseq","DESeq2","edgeR",
          "limma","ashr","gridExtra",
          "geepack","MASS","geeM",
          "R.utils", "BiocParallel","doParallel",
          "parallel","magrittr")

#   installed packages that were not installed already
source("http://bioconductor.org/biocLite.R")
biocLite(setdiff(pkgs,installed.packages()), suppressUpdates = TRUE)

#devtools::install_github("PratheepaJ/bootLong")
```

load packages:
```{r load_packages}
library(ggplot2)
library(dplyr)
library(tidyr)
library(phyloseq)
library(DESeq2)
library(edgeR)
library(limma)
library(ashr)
library(gridExtra)
library(geepack)
library(MASS)
library(geeM)
library(R.utils)
library(BiocParallel)
library(doParallel)
library(parallel)
library(magrittr)
devtools::load_all(".")
```

Set the computational resources
```{r}
ncores = as.integer(Sys.getenv("SLURM_NTASKS"))
if(is.na(ncores)) ncores <- parallel::detectCores()
```

##  Load the phyloseq

### Load the example dataset stored as a phyloseq object in the ``bootLong`` package (or use your own data stored as a phyloseq object)

```{r }
ps <- pssim
```

##  Summaries

###   Merge by subject    
```{r eval=FALSE}
psm <- merge_samples(ps, "SubjectID")  
sample_data(psm)$SubjectID <- rownames(sample_data(psm))
sample_data(psm)$Preterm <- factor(sample_data(psm)$Preterm)
omat <- as(otu_table(psm), "matrix")
nsam <- table(sample_data(ps)$SubjectID)
omn <- omat/as.vector(nsam)
otu_table(psm) <- otu_table(omn, taxa_are_rows=FALSE)
if(dim(otu_table(psm))[2]!=nsamples(psm)){otu_table(psm)=t(otu_table(psm))}
    
```

###   Summary

```{r eval=FALSE}
table(sample_data(ps)$SubjectID,sample_data(ps)$Time)
```

###   Sampling schedule

```{r }
theme_set(theme_bw())
set.theme <- theme_update(panel.border = element_blank(),
                    panel.grid = element_line(size = .8),
                    axis.ticks = element_blank(),
                    legend.title = element_text(size = 8),
                    legend.text = element_text(size = 6),
                    axis.text = element_text(size = 8),
                    axis.title = element_text(size = 8),
                    strip.background = element_blank(),
                    strip.text = element_text(size = 8),
                    legend.key = element_blank())


sample_data(ps)$Preterm <- as.factor(sample_data(ps)$Preterm)
p <- plot_sampling_schedule(ps, time_var = "Time", subjectID_var = "SubjectID", main_factor = "Preterm", theme_manual = set.theme)
p <- p + scale_color_discrete(name  ="Group",breaks=c("FALSE", "TRUE"),labels=c("Term", "Preterm"))
#ggsave("./sampling_schedule.pdf",plot=p,width = 8,height = 5.5)
```

##   Preprocessing

-   Filter ASVs
```{r }
threshold <- .01
keep_asv <- apply(otu_table(ps),1,function(x){sum(x>0)}) > threshold*nsamples(ps)
ps <- prune_taxa(keep_asv,ps)
```

##  Exploratory analysis

- Extract the common legend [https://github.com/hadley/ggplot2/wiki/Share-a-legend-between-two-ggplot2-graphs]
```{r common-legend}
plot_common_legend <- function(p){
    ggplot_feature = ggplot_gtable(ggplot_build(p))
    le <- which(sapply(ggplot_feature$grobs, function(x) x$name) == "guide-box")
    l <- ggplot_feature$grobs[[le]]
    return(l)
}
```

###  Correlogram
```{r corr, message=FALSE, warning=FALSE}
ps.tr <- psTransform(ps, 
                     main_factor = "Preterm") 

p.all <- longCorreloMultiple(ps.tr[[1]],
                             ps.tr[[2]], 
                             main_factor = "Preterm", 
                             time_var = "Time", 
                             starttaxa = 1, 
                             endtaxa = 6,
                             taxlevel = "Genus")

#   Change the legend labels
p.all <- lapply(p.all, function(x){
    x+scale_fill_discrete(name  ="Group", breaks=c("FALSE", "TRUE"), labels = c("Term", "Preterm"))
    })

#   extract the common legend for all taxa
leg <- plot_common_legend(p.all[[1]])

plist <- lapply(p.all,function(x){
    x+theme(legend.position="none")
    })

# p <- grid.arrange(arrangeGrob(grobs=plist,nrow=2,widths=c(3,3,3)),
#                   leg,
#                   ncol=2,
#                   widths=c(10,2))
# ggsave("./core_Sim.eps",plot=p,width = 8,height = 5.5)

grid.arrange(arrangeGrob(grobs=plist,nrow=2,widths=c(3,3,3)),
             leg,
             ncol=2,
             widths=c(10,2))
```


### longitudinal data lag-plots
```{r lag-plots, message=FALSE,warning=FALSE}
lags <- as.list(seq(1,8))

p.lags <- lapply(lags,function(x){
    longLagPlot(ps.tr[[2]], main_factor="Preterm", time_var = "Time", taxon = 1, x, taxlevel="Genus")})

#   Change the legend labels
p.lags <- lapply(p.lags, function(x){
    x+scale_color_discrete(name  ="Group", breaks=c("FALSE", "TRUE"), labels=c("Term", "Preterm"))
    })

leg <- plot_common_legend(p.lags[[1]])

plist <- lapply(p.lags,function(x){
    x+theme(legend.position="none")
    })


# p <- grid.arrange(arrangeGrob(grobs=plist,nrow=2,widths=c(3,3,3,3)),
#                   leg,
#                   ncol=2,
#                   widths=c(10,2))
# 
# ggsave("./lag_sim.eps",plot=p,width = 8,height = 5.5)

grid.arrange(arrangeGrob(grobs=plist,nrow=2,widths=c(3,3,3,3)), 
             leg, 
             ncol=2, 
             widths=c(10,2))

```

### Variogram for longitudinal data

```{r message=FALSE,warning=FALSE,fig.width=7.5,fig.height=5.5}
p.all <- longVarioMultiple(ps.tr[[1]],
                           ps.tr[[2]],
                           main_factor = "Preterm",
                           time_var="Time",
                           subjectID_var = "SubjectID",
                           starttaxa = 1,
                           endtaxa = 6,
                           point = FALSE,
                           taxlevel = "Genus")

#   Change the legend labels
p.all <- lapply(p.all, function(x){
    x + scale_color_discrete(name  ="Group", breaks=c("FALSE", "TRUE"), labels=c("Term", "Preterm "))
    })

leg <- plot_common_legend(p.all[[1]])

plist <- lapply(p.all,function(x){
    x + theme(legend.position="none")
    })

# p <- grid.arrange(arrangeGrob(grobs=plist, nrow=2, widths=c(3,3,3)),
#                   leg,
#                   ncol=2,
#                   widths=c(10,2))
# 
# ggsave("./vario_sim.eps", plot=p, width = 8, height = 5.5)

grid.arrange(arrangeGrob(grobs=plist, nrow=2, widths=c(3,3,3)),
             leg,
             ncol=2,
             widths=c(10,2))
```


#   The block bootstrap method

## Subsampling   
```{r message=FALSE,warning=FALSE,eval=FALSE}
R <- 2
RR <- 2
main_factor <- "Preterm"
time_var <- "Time"
subjectID_var = "SubjectID"
lI <- 5
omega <- .6
system.time(
    mse_results <- bootLongSubsampling(ps, 
                                       main_factor = main_factor,
                                       time_var = time_var, 
                                       subjectID_var = subjectID_var,
                                       lI = lI,  
                                       R = R, 
                                       RR = RR,
                                       omega = omega)
    )

#saveRDS(mse_results,"./bboot_sim.rds")
```

###   Inspect MSE plot
```{r message=FALSE,warning=FALSE,eval=FALSE}
omega <- .6
mse_results <- readRDS("./bboot_sim.rds")
blks <- length(mse_results)
mse <- list();for(i in 1:blks){mse[[i]] <- mse_results[[i]]$MSE_i}

mse.avg <- lapply(mse,function(x){mean(x,na.rm=T)})
mse.sum <- lapply(mse,function(x){sum(x,na.rm=T)})

mse <- unlist(mse.sum)
lblk <- seq(1,length(mse),by=1)
lblk.f <- as.factor(lblk)
dfp <- data.frame(mse=mse,lblk=lblk.f)

p.mse <- ggplot(dfp,aes(x=lblk,y=mse,group=1))+
    geom_point()+
    geom_line()+
    xlab("block size")+
    ylab("Mean squared error")+
    ggtitle(paste("MSE for Simulation",omega*100,"%","subsample"))+theme(plot.title = element_text(hjust = 0.5))

ggsave("./mse_sim.eps",plot=p.mse,width = 8,height = 5.5)

l.M <- lblk[mse==min(mse)]
l.M
l.opt <- ceiling((100/(omega*100))^(1/5)*l.M) 
l.opt
```

##   Run MBB with the optimal block size
```{r message=FALSE,warning=FALSE,eval=FALSE}
R <- 1000
RR <- 50
factors <- "Preterm"
time <- "Time"

system.time(boot_res <- bootLongMethod(ps,b=l.opt,R=R,RR=RR,factors=factors,time=time))

saveRDS(boot_res,"./boot_sim.rds")
```

###   Inspect the MBB results

```{r message=FALSE,warning=FALSE,eval=FALSE}
boot_res <- readRDS("./bboot_sim.rds")
FDR <- .05
taxalevel <- "Genus"
out <- boot_res[[1]] 

#   bootstrap values
T.star_obs <- boot_res[[5]] 

#  filter by FDR
out <- dplyr::filter(out,pvalue.adj <= FDR)
   
#   replace ASV by taxalevel
taxaName <- as.character(tax_table(ps)[as.character(out$ASV),taxalevel])

#   if you want to append Species names to Genus taxalevel
specName <- as.character(tax_table(ps)[as.character(out$ASV),"Species"])
tog <- character()

for(i in 1:length(taxaName)){
    if(!is.na(specName[i])){
    tog[i] <- paste(taxaName[i],specName[i])
    }else{
        tog[i] <- taxaName[i]
    }
}


#   to remove taxa with no taxalevel name
ind.na <- which(is.na(tog))

#   to add sequence variants
taxaN <- paste("SV",seq(1,length(out$ASV)),sep="")
tn <- paste(tog,taxaN,sep=".")

out$ASV <- tn #taxalevel name and variant number
#out$ASV <- taxaName    #   only taxalevel names
#out$ASV <- tog #   taxalevel and Species name
#out <- out[-ind.na,]

#   arrange by observed lfc
out <- dplyr::arrange(out,desc(stat))
#   dropped observed values of T
out <- out[,-6]

out <- dplyr::filter(out,!is.na(pvalue.adj))

#out <- filter(out,abs(stat)>1)

#   write the results table in latex
library(xtable)
print(xtable(out, type = "latex",digits = 3), file = "./boot_sim.tex")
```

