---
title: "Workflow : The Block Bootstrap Method for Longitudinal Microbiome Data"
author:
  name: Pratheepa Jeganathan
  affiliation: Department of Statistics, Stanford University
  email: jpratheepa31@gmail.com
date: "`r Sys.Date()`"
output: 
    rmarkdown::html_vignette:
        toc_float:  true
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: bootLong.bib
---


In this workflow we provide differential abundance analysis for longitudinal microbiome data. In addition, we provide statistical tools to explore the sampling schedule and within-subject dependence for each ASV. 

The manuscript is under revision and it's available in (stat arXiv) [https://arxiv.org/abs/1809.01832]. If you are intersted in learning the method, we suggest to look at our manuscript.

Our bootLong package requires (phyloseq)[https://joey711.github.io/phyloseq/] object to do the analysis. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.width=7.5, fig.height=5.5)
```

Install [R](https://www.r-project.org/) and [RStudio](https://www.rstudio.com/). Open this `Rmd` file in RStudio. Then run the following code to install all required packages.


Install packages: 
```{r install_packages, eval = FALSE}
pkgs <- c("ggplot2","dplyr","tidyr",
          "phyloseq", "limma","ashr",
          "gridExtra", "geepack","MASS",
          "geeM", "R.utils", "BiocParallel",
          "doParallel", "parallel","magrittr",
          "joineR", "DESeq2")

#   installed packages that were not installed already
source("http://bioconductor.org/biocLite.R")
biocLite(setdiff(pkgs,installed.packages()), suppressUpdates = TRUE)

devtools::install_github("PratheepaJ/bootLong")
```

load packages:
```{r load_packages}
library(ggplot2)
library(dplyr)
library(tidyr)
library(phyloseq)
library(limma)
library(ashr)
library(gridExtra)
library(MASS)
library(geeM)
library(R.utils)
library(BiocParallel)
library(doParallel)
library(parallel)
library(magrittr)
library(joineR)
library(DESeq2)
#library(bootLong)
devtools::load_all(".")
```

Set the computational resources: we need to specify the number of cores for subsampling method. 
```{r}
ncores = as.integer(Sys.getenv("SLURM_NTASKS"))
if(is.na(ncores)) ncores <- parallel::detectCores()
ncores
```

##  Load the phyloseq

### Load the example dataset stored as a phyloseq object in the ``bootLong`` package (or use your own data stored as a phyloseq object)

```{r }
ps <- pssim
```

##  Summary

After loading the phyloseq, we recommend to check the variable names and some summary for each variable in the sample table. In the example data, we have SubjectID, SampleID, Time, Covariates (Preterm).

```{r eval=FALSE}
names(sample_data(ps))
table(sample_data(ps)$SubjectID, sample_data(ps)$Time)
```

###   Sampling schedule

We can visualize the sampling schedule for each subject and facet by different conditions. This plot can be modified using your preferred theme, legends, etc. For example, `set.theme` can be changed to have point size 10, legend title can be changed from `Preterm` to `Group`, levels of `Preterm` can be changed to `Term` and `Preterm`, etc. 

```{r }
theme_set(theme_bw())
set.theme <- theme_update(panel.border = element_blank(),
                    panel.grid = element_line(size = .8),
                    axis.ticks = element_blank(),
                    legend.title = element_text(size = 8),
                    legend.text = element_text(size = 6),
                    axis.text = element_text(size = 8),
                    axis.title = element_text(size = 8),
                    strip.background = element_blank(),
                    strip.text = element_text(size = 8),
                    legend.key = element_blank())


sample_data(ps)$Preterm <- as.factor(sample_data(ps)$Preterm)

p <- plotSamplingSchedule(ps, time_var = "Time", subjectID_var = "SubjectID", main_factor = "Preterm", theme_manual = set.theme)

p <- p + scale_color_discrete(name  ="Group",breaks=c("FALSE", "TRUE"),labels=c("Term", "Preterm"))
p
#ggsave("./sampling_schedule.eps", plot=p, width = 8, height = 5.5)
```

##   Preprocessing

Preprocessing will help to reduce unwanted noise. 

[Tools](https://joey711.github.io/phyloseq/preprocess.html)

Filter ASVs: for example, we remove ASVs with less than 10% prevalence in all samples.  

```{r eval=FALSE}
if (dim(otu_table(ps))[2] != nsamples(ps)) {
        otu_table(ps) <- t(otu_table(ps))
    }
threshold <- .1
keep_asv <- apply(otu_table(ps),1,function(x){sum(x>0)}) > threshold*nsamples(ps)
ps <- prune_taxa(keep_asv,ps)
```

##  Exploratory analysis

Here we provide tools to explore the within-subject dependence. 

- Extract the common legend [https://github.com/hadley/ggplot2/wiki/Share-a-legend-between-two-ggplot2-graphs]

```{r common-legend}
plot_common_legend <- function(p){
    ggplot_feature = ggplot_gtable(ggplot_build(p))
    le <- which(sapply(ggplot_feature$grobs, function(x) x$name) == "guide-box")
    l <- ggplot_feature$grobs[[le]]
    return(l)
}
```


###  PACF

Partial autocorrelataion (PACF) at lag $h$ measures the correlation between repeated observations that are seperated by $h$ time units after adjusting for the correlation at shorter lags.  

1) We use `psTransform()` to get phyloseq objects with transformed count table and residuals after fitting a negative-binomial regression (residuals show the dependence in repeated observations).

2) We choose top six abundance ASVs (based on the transformed count) to visualize the dependence within-subject. We can choose different ASVs by changing `starttaxa` and `endtaxa`  arguments in `longPACFMultiple()`.

```{r pacf, message=FALSE, warning=FALSE}
ps.tr <- psTransform(ps, 
                     main_factor = "Preterm") 

p.all <- longPACFMultiple(ps.tr[[1]],
                             ps.tr[[2]], 
                             main_factor = "Preterm", 
                             time_var = "Time", 
                             starttaxa = 1, 
                             endtaxa = 6,
                             taxlevel = "Genus")

#   Change the legend labels
p.all <- lapply(p.all, function(x){
    x + scale_fill_discrete(name  ="Group", breaks=c("FALSE", "TRUE"), labels = c("Term", "Preterm"))
    })

#   extract the common legend for all taxa
leg <- plot_common_legend(p.all[[1]])

plist <- lapply(p.all,function(x){
    x+theme(legend.position="none")
    })

# p <- grid.arrange(arrangeGrob(grobs=plist,nrow=2,widths=c(3,3,3)),
#                   leg,
#                   ncol=2,
#                   widths=c(10,2))
# ggsave("./core_Sim.eps",plot=p,width = 8,height = 5.5)

grid.arrange(arrangeGrob(grobs=plist,nrow=2,widths=c(3,3,3)),
             leg,
             ncol=2,
             widths=c(10,2))
```

Only the largest spike is observed at lag 1 for both term and preterm. However, almost all the ASVs show that the PACF is less than .25 (sufficiently zero) after lag 4. Therefore, the initial block size is 5 (lag 4 corresponds to block size 5). 


###  Correlogram
```{r corr, message=FALSE, warning=FALSE}
p.all <- longCorreloMultiple(ps.tr[[1]],
                             ps.tr[[2]], 
                             main_factor = "Preterm", 
                             time_var = "Time", 
                             starttaxa = 1, 
                             endtaxa = 6,
                             taxlevel = "Genus")

#   Change the legend labels
p.all <- lapply(p.all, function(x){
    x + scale_fill_discrete(name  ="Group", breaks=c("FALSE", "TRUE"), labels = c("Term", "Preterm"))
    })

#   extract the common legend for all taxa
leg <- plot_common_legend(p.all[[1]])

plist <- lapply(p.all,function(x){
    x+theme(legend.position="none")
    })

# p <- grid.arrange(arrangeGrob(grobs=plist,nrow=2,widths=c(3,3,3)),
#                   leg,
#                   ncol=2,
#                   widths=c(10,2))
# ggsave("./core_Sim.eps",plot=p,width = 8,height = 5.5)

grid.arrange(arrangeGrob(grobs=plist,nrow=2,widths=c(3,3,3)),
             leg,
             ncol=2,
             widths=c(10,2))
```

We observe that the correlogram tends to be sufficiently zero (first time) at lag 4 for almost all the ASVs. Therefore, the initial block size is 5.


### longitudinal data lag-plots
```{r lag-plots, message=FALSE,warning=FALSE}
lags <- as.list(seq(1,8))

p.lags <- lapply(lags,function(x){
    longLagPlot(ps.tr[[2]], 
        main_factor="Preterm", 
        time_var = "Time", 
        taxon = 1, 
        x, 
        taxlevel="Genus")})

#   Change the legend labels
p.lags <- lapply(p.lags, function(x){
    x+scale_color_discrete(name  ="Group", breaks=c("FALSE", "TRUE"), labels=c("Term", "Preterm"))
    })

leg <- plot_common_legend(p.lags[[1]])

plist <- lapply(p.lags,function(x){
    x+theme(legend.position="none")
    })


# p <- grid.arrange(arrangeGrob(grobs=plist,nrow=2,widths=c(3,3,3,3)),
#                   leg,
#                   ncol=2,
#                   widths=c(10,2))
# 
# ggsave("./lag_sim.eps",plot=p,width = 8,height = 5.5)

grid.arrange(arrangeGrob(grobs=plist,nrow=2,widths=c(3,3,3,3)), 
             leg, 
             ncol=2, 
             widths=c(10,2))

```


We observe that for the top abundance ASV, the lag-plot at lag 4 deviates from a linear line. Thus, we choose an initial block size of 5.

### Variogram for longitudinal data

We can plot points (residuals) by choosing argument `point = TRUE` in `longVarioMultiple()`.

```{r message=FALSE, warning=FALSE}
p.all <- longVarioMultiple(ps.tr[[1]],
                           ps.tr[[2]],
                           main_factor = "Preterm",
                           time_var="Time",
                           subjectID_var = "SubjectID",
                           starttaxa = 1,
                           endtaxa = 6,
                           point = TRUE,
                           taxlevel = "Species")

#   Change the legend labels
p.all <- lapply(p.all, function(x){
    x + scale_color_discrete(name  ="Group", breaks=c("FALSE", "TRUE"), labels=c("Term", "Preterm "))
    })

leg <- plot_common_legend(p.all[[1]])

plist <- lapply(p.all,function(x){
    x + theme(legend.position="none")
    })

# p <- grid.arrange(arrangeGrob(grobs=plist, nrow=2, widths=c(3,3,3)),
#                   leg,
#                   ncol=2,
#                   widths=c(10,2))
# 
# ggsave("./vario_sim.eps", plot=p, width = 8, height = 5.5)

grid.arrange(arrangeGrob(grobs=plist, nrow=2, widths=c(3,3,3)),
             leg,
             ncol=2,
             widths=c(10,2))
```


We observe that variogram reaches the residual variance at lag 4 for almost all of the top six ASVs. Thus, we choose an initial block size of 5.

All the exploratory tools suggest an inital block size of 5.

We will choose 60\% of repeated observations for the subsampling because we can compute mean squared error of two-sided probability over FIVE subsamples (because there are 10 repeated observations from each subject). 

Note: there is a trade-off between choosing the percentage and creating a number of subsamples. We need to create as larger as possible number of bootstrap samples with initial block size 5 (prefer to have a larger percentage and should be at least 6 repeated observations), and we need to create as many subsamples as possible (smaller percentage and should be at least 6 repeated observations.)


#   The block bootstrap method

First, we identify the opitmal block size for the subsample. We use the initial block size 5 ($l_{I} =5$) and subsample percentage 60\% ($\omega = .6$) to identify the opitmal block size. 

## Subsampling

```{r message=FALSE,warning=FALSE, eval=FALSE}
R <- 5
RR <- 4
main_factor <- "Preterm"
time_var <- "Time"
subjectID_var = "SubjectID"
sampleID_var = "SampleID"
lI <- 4
omega <- .6

system.time(
    mse.results <- bootLongSubsampling(ps = ps, main_factor = main_factor, time_var = time_var, subjectID_var = subjectID_var, sampleID_var = sampleID_var, lI = lI, R = R, RR = RR, omega = omega, lC1 = 1, lC2 = NULL, ncores = ncroes)
)


#saveRDS(mse.results,"./MSE.rds")
```

###   Inspect MSE plot

Second, we identify the optimal block size for the original data using the formula.

$$l_{o} = \left(\frac{1}{\omega}\right)^{1/5}l_{\omega}$$.


```{r message=FALSE,warning=FALSE, eval=FALSE}
omega <- .6
#mse_results <- readRDS("./MSE.rds")
blks <- length(mse_results)
mse <- list()

for(i in 1:blks){
    mse[[i]] <- mse_results[[i]]$MSE_i
    }

mse.avg <- lapply(mse,function(x){mean(x,na.rm=T)})
mse.sum <- lapply(mse,function(x){sum(x,na.rm=T)})

mse <- unlist(mse.sum)
lblk <- seq(1,length(mse),by=1)
lblk.f <- as.factor(lblk)
dfp <- data.frame(mse=mse,lblk=lblk.f)

p.mse <- ggplot(dfp,aes(x=lblk,y=mse,group=1))+
    geom_point()+
    geom_line()+
    xlab("block size")+
    ylab("Mean squared error")+
    ggtitle(paste("MSE for Simulation",omega*100,"%","subsample"))+theme(plot.title = element_text(hjust = 0.5))

ggsave("./mse_sim.eps", plot=p.mse, width = 8, height = 5.5)

l.omega <- lblk[mse==min(mse)]
l.omega
l.opt <- ceiling((100/(omega*100))^(1/5)*l.omega) 
l.opt
```


##   Run MBB with the optimal block size

Finally, we run the block bootstrap method with the optimal block size for differential abundance analysis.


```{r message=FALSE, warning=FALSE, eval=FALSE}
R <- 5
RR <- 4
main_factor <- "Preterm"
time_var <- "Time"
subjectID_var = "SubjectID"
sampleID_var = "SampleID"

system.time(
    boot_res <- bootLongMethod(ps, 
        main_factor = main_factor, 
        time_var = time_var,   
        sampleID_var = sampleID_var,
        subjectID_var = subjectID_var, 
        b = l.opt, 
        R = R, 
        RR = RR)
    )

#saveRDS(boot_res,"./MBB.rds")
```

###   Inspect the MBB results

We can make a summary of differential abundance ASV.

```{r message=FALSE,warning=FALSE, eval=FALSE}
boot_res <- readRDS("./MBB.rds")
FDR <- .05
taxalevel <- "Genus"
out <- boot_res[[1]] 

#   bootstrap values
T.star_obs <- boot_res[[5]] 

#  filter by FDR
out <- dplyr::filter(out,pvalue.adj <= FDR)
   
#   replace ASV by taxalevel
taxaName <- as.character(tax_table(ps)[as.character(out$ASV),taxalevel])

#   if you want to append Species names to Genus taxalevel
specName <- as.character(tax_table(ps)[as.character(out$ASV),"Species"])
tog <- character()

for(i in 1:length(taxaName)){
    if(!is.na(specName[i])){
    tog[i] <- paste(taxaName[i],specName[i])
    }else{
        tog[i] <- taxaName[i]
    }
}


#   to remove taxa with no taxalevel name
ind.na <- which(is.na(tog))

#   to add sequence variants
taxaN <- paste("SV",seq(1,length(out$ASV)),sep="")
tn <- paste(tog,taxaN,sep=".")

out$ASV <- tn #taxalevel name and variant number
#out$ASV <- taxaName    #   only taxalevel names
#out$ASV <- tog #   taxalevel and Species name
#out <- out[-ind.na,]

#   arrange by observed lfc
out <- dplyr::arrange(out,desc(stat))
#   dropped observed values of T
out <- out[,-6]

out <- dplyr::filter(out,!is.na(pvalue.adj))

#out <- filter(out,abs(stat)>1)

#   write the results table in latex
library(xtable)
print(xtable(out, type = "latex",digits = 3), file = "./boot_sim.tex")
```

